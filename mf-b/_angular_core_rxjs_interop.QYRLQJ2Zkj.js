import{a as p,b as h}from"./chunk-4CLCTAJ7.js";import{assertInInjectionContext as d,inject as l,DestroyRef as a,\u0275RuntimeError as f,\u0275getOutputDestroyRef as x,Injector as m,effect as j,untracked as b,\u0275microtaskEffect as O,signal as v,computed as R,PendingTasks as S,resource as q}from"@angular/core";import{Observable as g,ReplaySubject as w}from"rxjs";import{takeUntil as E}from"rxjs/operators";function k(n){n||(d(k),n=l(a));let e=new g(t=>n.onDestroy(t.next.bind(t)));return t=>t.pipe(E(e))}var y=class{source;destroyed=!1;destroyRef=l(a);constructor(e){this.source=e,this.destroyRef.onDestroy(()=>{this.destroyed=!0})}subscribe(e){if(this.destroyed)throw new f(953,!1);let t=this.source.pipe(k(this.destroyRef)).subscribe({next:r=>e(r)});return{unsubscribe:()=>t.unsubscribe()}}};function N(n,e){return new y(n)}function P(n){let e=x(n);return new g(t=>{e?.onDestroy(()=>t.complete());let r=n.subscribe(u=>t.next(u));return()=>r.unsubscribe()})}function D(n,e){!e?.injector&&d(D);let t=e?.injector??l(m),r=new w(1),u=j(()=>{let o;try{o=n()}catch(c){b(()=>r.error(c));return}b(()=>r.next(o))},{injector:t,manualCleanup:!0});return t.get(a).onDestroy(()=>{u.destroy(),r.complete()}),r.asObservable()}function A(n,e){!e?.injector&&d(D);let t=e?.injector??l(m),r=new w(1),u=O(()=>{let o;try{o=n()}catch(c){b(()=>r.error(c));return}b(()=>r.next(o))},{injector:t,manualCleanup:!0});return t.get(a).onDestroy(()=>{u.destroy(),r.complete()}),r.asObservable()}function M(n,e){let t=!e?.manualCleanup;t&&!e?.injector&&d(M);let r=t?e?.injector?.get(a)??l(a):null,u=C(e?.equal),o;e?.requireSync?o=v({kind:0},{equal:u}):o=v({kind:1,value:e?.initialValue},{equal:u});let c=n.subscribe({next:s=>o.set({kind:1,value:s}),error:s=>{if(e?.rejectErrors)throw s;o.set({kind:2,error:s})}});if(e?.requireSync&&o().kind===0)throw new f(601,!1);return r?.onDestroy(c.unsubscribe.bind(c)),R(()=>{let s=o();switch(s.kind){case 1:return s.value;case 2:throw s.error;case 0:throw new f(601,!1)}},{equal:e?.equal})}function C(n=Object.is){return(e,t)=>e.kind===1&&t.kind===1&&n(e.value,t.value)}function I(n){n===void 0&&(d(I),n=l(m));let e=n.get(S);return t=>new g(r=>{let u=e.add(),o=!1;function c(){o||(u(),o=!0)}let s=t.subscribe({next:i=>{r.next(i),c()},complete:()=>{r.complete(),c()},error:i=>{r.error(i),c()}});return s.add(()=>{r.unsubscribe(),c()}),s})}function T(n){return n?.injector||d(T),q(h(p({},n),{loader:void 0,stream:e=>{let t,r=()=>t.unsubscribe();e.abortSignal.addEventListener("abort",r);let u=v({value:void 0}),o,c=new Promise(i=>o=i);function s(i){u.set(i),o?.(u),o=void 0}return t=n.loader(e).subscribe({next:i=>s({value:i}),error:i=>s({error:i}),complete:()=>{o&&s({error:new Error("Resource completed before producing a value")}),e.abortSignal.removeEventListener("abort",r)}}),c}}))}export{N as outputFromObservable,P as outputToObservable,I as pendingUntilEvent,T as rxResource,k as takeUntilDestroyed,D as toObservable,M as toSignal,A as \u0275toObservableMicrotask};
/*! Bundled license information:

@angular/core/fesm2022/rxjs-interop.mjs:
  (**
   * @license Angular v19.2.10
   * (c) 2010-2025 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
